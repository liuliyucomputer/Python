# Oracle数据库高级特性

## 1. PL/SQL编程

### 1.1 PL/SQL概述
PL/SQL（Procedural Language/SQL）是Oracle的过程化扩展语言，结合了SQL的数据操作能力和过程化编程语言的控制结构。

### 1.2 PL/SQL基本结构
```sql
-- 匿名块
DECLARE
  -- 声明部分
  v_employee_id NUMBER := 100;
  v_first_name VARCHAR2(20);
  v_last_name VARCHAR2(25);
BEGIN
  -- 执行部分
  SELECT first_name, last_name INTO v_first_name, v_last_name
  FROM employees WHERE employee_id = v_employee_id;
  
  DBMS_OUTPUT.PUT_LINE('Employee: ' || v_first_name || ' ' || v_last_name);
EXCEPTION
  -- 异常处理部分
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('Employee not found');
  WHEN TOO_MANY_ROWS THEN
    DBMS_OUTPUT.PUT_LINE('Multiple employees found');
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/
```

### 1.3 PL/SQL变量和常量
```sql
DECLARE
  -- 变量
  v_emp_count NUMBER;
  v_salary NUMBER(8,2) := 5000;
  v_hire_date DATE := SYSDATE;
  v_full_name VARCHAR2(50) := 'John Doe';
  
  -- 常量
  c_tax_rate CONSTANT NUMBER(3,2) := 0.15;
  
  -- %TYPE类型
  v_emp_id employees.employee_id%TYPE;
  v_emp_name employees.first_name%TYPE;
  
  -- %ROWTYPE类型
  v_employee employees%ROWTYPE;
BEGIN
  -- 使用变量
  v_emp_id := 101;
  SELECT * INTO v_employee FROM employees WHERE employee_id = v_emp_id;
  DBMS_OUTPUT.PUT_LINE('Employee: ' || v_employee.first_name || ' ' || v_employee.last_name);
  DBMS_OUTPUT.PUT_LINE('Salary: ' || v_employee.salary);
  DBMS_OUTPUT.PUT_LINE('Tax: ' || v_employee.salary * c_tax_rate);
END;
/
```

### 1.4 PL/SQL控制结构

#### 1.4.1 条件语句
```sql
DECLARE
  v_salary NUMBER := 7500;
  v_grade VARCHAR2(10);
BEGIN
  -- IF-THEN-ELSE语句
  IF v_salary < 5000 THEN
    v_grade := 'C';
  ELSIF v_salary < 10000 THEN
    v_grade := 'B';
  ELSE
    v_grade := 'A';
  END IF;
  DBMS_OUTPUT.PUT_LINE('Salary Grade: ' || v_grade);
  
  -- CASE语句
  CASE
    WHEN v_salary < 5000 THEN
      v_grade := 'C';
    WHEN v_salary < 10000 THEN
      v_grade := 'B';
    ELSE
      v_grade := 'A';
  END CASE;
  DBMS_OUTPUT.PUT_LINE('Salary Grade (CASE): ' || v_grade);
END;
/
```

#### 1.4.2 循环语句
```sql
DECLARE
  v_count NUMBER := 1;
BEGIN
  -- LOOP循环
  LOOP
    DBMS_OUTPUT.PUT_LINE('LOOP: ' || v_count);
    v_count := v_count + 1;
    EXIT WHEN v_count > 5;
  END LOOP;
  
  -- WHILE循环
  v_count := 1;
  WHILE v_count <= 5 LOOP
    DBMS_OUTPUT.PUT_LINE('WHILE: ' || v_count);
    v_count := v_count + 1;
  END LOOP;
  
  -- FOR循环
  FOR i IN 1..5 LOOP
    DBMS_OUTPUT.PUT_LINE('FOR: ' || i);
  END LOOP;
  
  -- 反向FOR循环
  FOR i IN REVERSE 1..5 LOOP
    DBMS_OUTPUT.PUT_LINE('REVERSE FOR: ' || i);
  END LOOP;
END;
/
```

### 1.5 PL/SQL游标

#### 1.5.1 隐式游标
```sql
DECLARE
  v_emp_count NUMBER;
BEGIN
  -- DML隐式游标
  UPDATE employees SET salary = salary * 1.05 WHERE department_id = 50;
  DBMS_OUTPUT.PUT_LINE('Updated ' || SQL%ROWCOUNT || ' employees');
  
  -- SELECT INTO隐式游标
  SELECT COUNT(*) INTO v_emp_count FROM employees;
  DBMS_OUTPUT.PUT_LINE('Total employees: ' || v_emp_count);
END;
/
```

#### 1.5.2 显式游标
```sql
DECLARE
  -- 声明游标
  CURSOR c_employees IS
    SELECT employee_id, first_name, last_name, salary
    FROM employees WHERE department_id = 50;
  
  -- 游标变量
  v_emp_id employees.employee_id%TYPE;
  v_first_name employees.first_name%TYPE;
  v_last_name employees.last_name%TYPE;
  v_salary employees.salary%TYPE;
BEGIN
  -- 打开游标
  OPEN c_employees;
  
  -- 提取数据
  LOOP
    FETCH c_employees INTO v_emp_id, v_first_name, v_last_name, v_salary;
    EXIT WHEN c_employees%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Employee: ' || v_first_name || ' ' || v_last_name || ', Salary: ' || v_salary);
  END LOOP;
  
  -- 关闭游标
  CLOSE c_employees;
END;
/
```

#### 1.5.3 游标FOR循环
```sql
DECLARE
  -- 声明游标
  CURSOR c_employees (p_department_id NUMBER) IS
    SELECT employee_id, first_name, last_name, salary
    FROM employees WHERE department_id = p_department_id;
BEGIN
  -- 游标FOR循环（自动打开、提取、关闭）
  FOR r_employee IN c_employees(50) LOOP
    DBMS_OUTPUT.PUT_LINE('Employee: ' || r_employee.first_name || ' ' || r_employee.last_name || ', Salary: ' || r_employee.salary);
  END LOOP;
END;
/
```

#### 1.5.4 REF游标
```sql
DECLARE
  -- 声明REF游标类型
  TYPE ref_cursor_type IS REF CURSOR;
  v_ref_cursor ref_cursor_type;
  
  v_emp_id NUMBER;
  v_first_name VARCHAR2(20);
  v_last_name VARCHAR2(25);
  
  -- 动态SQL
  v_sql VARCHAR2(200);
BEGIN
  -- 打开REF游标
  v_sql := 'SELECT employee_id, first_name, last_name FROM employees WHERE department_id = :dept_id';
  OPEN v_ref_cursor FOR v_sql USING 50;
  
  -- 提取数据
  LOOP
    FETCH v_ref_cursor INTO v_emp_id, v_first_name, v_last_name;
    EXIT WHEN v_ref_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Employee: ' || v_first_name || ' ' || v_last_name);
  END LOOP;
  
  -- 关闭REF游标
  CLOSE v_ref_cursor;
END;
/
```

## 2. 存储过程和函数

### 2.1 存储过程
```sql
-- 创建存储过程
CREATE OR REPLACE PROCEDURE update_employee_salary(
  p_employee_id IN employees.employee_id%TYPE,
  p_percentage IN NUMBER
) AS
  v_current_salary employees.salary%TYPE;
BEGIN
  -- 获取当前工资
  SELECT salary INTO v_current_salary
  FROM employees WHERE employee_id = p_employee_id;
  
  -- 更新工资
  UPDATE employees
  SET salary = salary * (1 + p_percentage / 100)
  WHERE employee_id = p_employee_id;
  
  DBMS_OUTPUT.PUT_LINE('Updated salary for employee ' || p_employee_id || ': ' || 
                     v_current_salary || ' -> ' || (v_current_salary * (1 + p_percentage / 100)));
  
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      DBMS_OUTPUT.PUT_LINE('Employee ' || p_employee_id || ' not found');
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END update_employee_salary;
/

-- 执行存储过程
EXECUTE update_employee_salary(100, 10);

-- 在PL/SQL块中调用
BEGIN
  update_employee_salary(101, 5);
  update_employee_salary(102, 8);
END;
/
```

### 2.2 函数
```sql
-- 创建函数
CREATE OR REPLACE FUNCTION calculate_annual_salary(
  p_salary IN employees.salary%TYPE,
  p_commission_pct IN employees.commission_pct%TYPE
) RETURN NUMBER AS
  v_annual_salary NUMBER;
BEGIN
  -- 计算年薪（包括基本工资和佣金）
  IF p_commission_pct IS NULL THEN
    v_annual_salary := p_salary * 12;
  ELSE
    v_annual_salary := (p_salary + (p_salary * p_commission_pct)) * 12;
  END IF;
  
  RETURN v_annual_salary;
END calculate_annual_salary;
/

-- 使用函数
SELECT employee_id, first_name, last_name, salary, commission_pct,
       calculate_annual_salary(salary, commission_pct) AS annual_salary
FROM employees WHERE department_id = 80;

-- 在PL/SQL块中调用函数
DECLARE
  v_annual_salary NUMBER;
BEGIN
  v_annual_salary := calculate_annual_salary(10000, 0.1);
  DBMS_OUTPUT.PUT_LINE('Annual Salary: ' || v_annual_salary);
END;
/
```

### 2.3 包
```sql
-- 创建包规范
CREATE OR REPLACE PACKAGE employee_package AS
  -- 常量
  c_max_salary CONSTANT NUMBER := 100000;
  
  -- 类型定义
  TYPE employee_rec IS RECORD (
    employee_id NUMBER,
    first_name VARCHAR2(20),
    last_name VARCHAR2(25),
    salary NUMBER(8,2)
  );
  
  -- 函数和过程声明
  PROCEDURE update_salary(p_employee_id IN NUMBER, p_percentage IN NUMBER);
  FUNCTION get_employee(p_employee_id IN NUMBER) RETURN employee_rec;
  FUNCTION calculate_bonus(p_salary IN NUMBER) RETURN NUMBER;
END employee_package;
/

-- 创建包体
CREATE OR REPLACE PACKAGE BODY employee_package AS
  -- 过程实现
  PROCEDURE update_salary(p_employee_id IN NUMBER, p_percentage IN NUMBER) AS
  BEGIN
    UPDATE employees
    SET salary = salary * (1 + p_percentage / 100)
    WHERE employee_id = p_employee_id;
  END update_salary;
  
  -- 函数实现
  FUNCTION get_employee(p_employee_id IN NUMBER) RETURN employee_rec AS
    v_employee employee_rec;
  BEGIN
    SELECT employee_id, first_name, last_name, salary
    INTO v_employee
    FROM employees WHERE employee_id = p_employee_id;
    
    RETURN v_employee;
  END get_employee;
  
  FUNCTION calculate_bonus(p_salary IN NUMBER) RETURN NUMBER AS
  BEGIN
    IF p_salary > c_max_salary THEN
      RETURN p_salary * 0.15;
    ELSE
      RETURN p_salary * 0.1;
    END IF;
  END calculate_bonus;
END employee_package;
/

-- 使用包
DECLARE
  v_employee employee_package.employee_rec;
  v_bonus NUMBER;
BEGIN
  v_employee := employee_package.get_employee(100);
  DBMS_OUTPUT.PUT_LINE('Employee: ' || v_employee.first_name || ' ' || v_employee.last_name);
  DBMS_OUTPUT.PUT_LINE('Salary: ' || v_employee.salary);
  
  v_bonus := employee_package.calculate_bonus(v_employee.salary);
  DBMS_OUTPUT.PUT_LINE('Bonus: ' || v_bonus);
  
  employee_package.update_salary(100, 5);
  DBMS_OUTPUT.PUT_LINE('Salary updated by 5%');
END;
/
```

## 3. 触发器

### 3.1 触发器概述
触发器是在特定事件发生时自动执行的PL/SQL块，可以用于实现数据完整性、审计跟踪、业务规则等。

### 3.2 触发器类型
- **DML触发器**：在INSERT、UPDATE、DELETE操作时触发
- **DDL触发器**：在CREATE、ALTER、DROP等DDL操作时触发
- **系统事件触发器**：在数据库启动、关闭等系统事件时触发
- **INSTEAD OF触发器**：在视图上替代实际操作的触发器

### 3.3 DML触发器
```sql
-- 行级触发器（FOR EACH ROW）
CREATE OR REPLACE TRIGGER employees_salary_trigger
BEFORE UPDATE OF salary ON employees
FOR EACH ROW
WHEN (new.salary > old.salary * 1.2)  -- 工资增长超过20%
BEGIN
  -- 记录审计信息
  INSERT INTO salary_audit (employee_id, old_salary, new_salary, change_date, changed_by)
  VALUES (:old.employee_id, :old.salary, :new.salary, SYSDATE, USER);
  
  -- 发送通知（示例）
  DBMS_OUTPUT.PUT_LINE('Warning: Salary increase超过20% for employee ' || :old.employee_id);
END;
/

-- 语句级触发器
CREATE OR REPLACE TRIGGER employees_bulk_update_trigger
AFTER UPDATE ON employees
BEGIN
  -- 记录批量更新信息
  INSERT INTO employees_audit (action, action_date, action_by)
  VALUES ('BULK UPDATE', SYSDATE, USER);
END;
/

-- 复合触发器
CREATE OR REPLACE TRIGGER employees_compound_trigger
  -- 声明部分
  v_emp_count NUMBER := 0;
  
  -- BEFORE STATEMENT
  BEFORE STATEMENT IS
  BEGIN
    v_emp_count := 0;
  END BEFORE STATEMENT;
  
  -- BEFORE EACH ROW
  BEFORE EACH ROW IS
  BEGIN
    v_emp_count := v_emp_count + 1;
  END BEFORE EACH ROW;
  
  -- AFTER EACH ROW
  AFTER EACH ROW IS
  BEGIN
    -- 可以在这里添加行级处理
  END AFTER EACH ROW;
  
  -- AFTER STATEMENT
  AFTER STATEMENT IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Processed ' || v_emp_count || ' employees');
  END AFTER STATEMENT;
END employees_compound_trigger;
/
```

### 3.4 INSTEAD OF触发器
```sql
-- 创建视图
CREATE VIEW employees_departments_view AS
SELECT e.employee_id, e.first_name, e.last_name, e.department_id, d.department_name
FROM employees e JOIN departments d ON e.department_id = d.department_id;

-- 创建INSTEAD OF触发器
CREATE OR REPLACE TRIGGER employees_departments_view_trigger
INSTEAD OF UPDATE ON employees_departments_view
FOR EACH ROW
BEGIN
  -- 更新employees表
  UPDATE employees
  SET first_name = :new.first_name,
      last_name = :new.last_name,
      department_id = :new.department_id
  WHERE employee_id = :new.employee_id;
  
  -- 如果部门名称也更改了，更新departments表
  IF :new.department_name != :old.department_name THEN
    UPDATE departments
    SET department_name = :new.department_name
    WHERE department_id = :new.department_id;
  END IF;
END;
/
```

## 4. 索引优化

### 4.1 索引类型
- **B树索引**：默认索引类型，适合高基数列
- **位图索引**：适合低基数列，如性别、状态等
- **函数索引**：基于函数或表达式的索引
- **分区索引**：与分区表配合使用
- **反向键索引**：减少索引热点问题
- **降序索引**：按降序存储索引值
- **复合索引**：基于多个列的索引

### 4.2 索引创建和管理
```sql
-- B树索引
CREATE INDEX idx_employees_last_name ON employees(last_name);

-- 唯一索引
CREATE UNIQUE INDEX idx_employees_email ON employees(email);

-- 位图索引
CREATE BITMAP INDEX idx_employees_gender ON employees(gender);

-- 函数索引
CREATE INDEX idx_employees_upper_email ON employees(UPPER(email));
CREATE INDEX idx_employees_hire_year ON employees(EXTRACT(YEAR FROM hire_date));

-- 复合索引
CREATE INDEX idx_employees_dept_salary ON employees(department_id, salary DESC);

-- 反向键索引
CREATE INDEX idx_employees_empid_reverse ON employees(employee_id) REVERSE;

-- 查看索引信息
SELECT index_name, table_name, uniqueness, index_type
FROM user_indexes WHERE table_name = 'EMPLOYEES';

-- 重建索引
ALTER INDEX idx_employees_last_name REBUILD;
ALTER INDEX idx_employees_last_name REBUILD ONLINE;  -- 在线重建

-- 收集索引统计信息
EXEC DBMS_STATS.GATHER_INDEX_STATS('HR', 'IDX_EMPLOYEES_LAST_NAME');
```

### 4.3 索引使用策略
- **选择性**：选择选择性高的列创建索引
- **复合索引顺序**：将选择性高的列放在前面
- **避免过度索引**：索引会增加DML操作的开销
- **考虑查询模式**：根据常用查询创建合适的索引
- **使用索引覆盖**：查询只需要从索引中获取数据

### 4.4 执行计划分析
```sql
-- 查看执行计划
EXPLAIN PLAN FOR
SELECT first_name, last_name, salary
FROM employees WHERE department_id = 50 AND salary > 7000;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- 使用AUTOTRACE
SET AUTOTRACE ON EXPLAIN
SELECT first_name, last_name, salary
FROM employees WHERE department_id = 50 AND salary > 7000;

-- 查看索引使用情况
SELECT index_name, table_name, monitoring, used
FROM v$object_usage WHERE table_name = 'EMPLOYEES';

-- 开始监控索引
ALTER INDEX idx_employees_dept_salary MONITORING USAGE;
```

## 5. 分区表和分区索引

### 5.1 分区表概述
分区表将大表分割成多个小的子表（分区），提高查询性能和管理效率。

### 5.2 分区类型
- **范围分区**：按列的范围值分区
- **列表分区**：按列的离散值分区
- **哈希分区**：按哈希函数值分区
- **复合分区**：组合多种分区方法

### 5.3 范围分区
```sql
-- 创建范围分区表
CREATE TABLE orders (
  order_id NUMBER PRIMARY KEY,
  order_date DATE,
  customer_id NUMBER,
  total_amount NUMBER(8,2)
)
PARTITION BY RANGE (order_date) (
  PARTITION orders_q1_2023 VALUES LESS THAN (TO_DATE('2023-04-01', 'YYYY-MM-DD')),
  PARTITION orders_q2_2023 VALUES LESS THAN (TO_DATE('2023-07-01', 'YYYY-MM-DD')),
  PARTITION orders_q3_2023 VALUES LESS THAN (TO_DATE('2023-10-01', 'YYYY-MM-DD')),
  PARTITION orders_q4_2023 VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD')),
  PARTITION orders_future VALUES LESS THAN (MAXVALUE)
);

-- 查询特定分区
SELECT * FROM orders PARTITION (orders_q1_2023);

-- 插入数据
INSERT INTO orders (order_id, order_date, customer_id, total_amount)
VALUES (1, TO_DATE('2023-03-15', 'YYYY-MM-DD'), 100, 500);

-- 添加新分区
ALTER TABLE orders ADD PARTITION orders_q1_2024 VALUES LESS THAN (TO_DATE('2024-04-01', 'YYYY-MM-DD'));

-- 合并分区
ALTER TABLE orders MERGE PARTITIONS orders_q1_2023, orders_q2_2023 INTO PARTITION orders_h1_2023;

-- 拆分分区
ALTER TABLE orders SPLIT PARTITION orders_h1_2023 AT (TO_DATE('2023-04-01', 'YYYY-MM-DD'))
INTO (PARTITION orders_q1_2023, PARTITION orders_q2_2023);
```

### 5.4 列表分区
```sql
-- 创建列表分区表
CREATE TABLE employees_by_region (
  employee_id NUMBER PRIMARY KEY,
  first_name VARCHAR2(20),
  last_name VARCHAR2(25),
  department_id NUMBER,
  region VARCHAR2(10)
)
PARTITION BY LIST (region) (
  PARTITION employees_north VALUES ('NORTH'),
  PARTITION employees_south VALUES ('SOUTH'),
  PARTITION employees_east VALUES ('EAST'),
  PARTITION employees_west VALUES ('WEST'),
  PARTITION employees_other VALUES (DEFAULT)
);
```

### 5.5 哈希分区
```sql
-- 创建哈希分区表
CREATE TABLE large_table (
  id NUMBER PRIMARY KEY,
  data VARCHAR2(100)
)
PARTITION BY HASH (id)
PARTITIONS 8;
```

### 5.6 复合分区
```sql
-- 范围-哈希复合分区
CREATE TABLE sales (
  sale_id NUMBER PRIMARY KEY,
  sale_date DATE,
  product_id NUMBER,
  quantity NUMBER,
  amount NUMBER(8,2)
)
PARTITION BY RANGE (sale_date)
SUBPARTITION BY HASH (product_id)
SUBPARTITIONS 4
(
  PARTITION sales_2023 VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD')),
  PARTITION sales_2024 VALUES LESS THAN (TO_DATE('2025-01-01', 'YYYY-MM-DD'))
);
```

## 6. 高级安全特性

### 6.1 数据加密
```sql
-- 透明数据加密 (TDE)
-- 1. 创建加密钱包
ALTER SYSTEM SET encryption_key_location = '/u01/oracle/wallet' SCOPE=SPFILE;

-- 2. 打开钱包
ALTER SYSTEM SET encryption wallet open identified by "wallet_password";

-- 3. 创建加密表空间
CREATE TABLESPACE encrypted_ts
DATAFILE '/u01/oradata/ORCL/encrypted01.dbf' SIZE 100M
ENCRYPTION USING 'AES256' DEFAULT STORAGE(ENCRYPT);

-- 4. 创建加密表
CREATE TABLE sensitive_data (
  id NUMBER PRIMARY KEY,
  sensitive_info VARCHAR2(100)
)
TABLESPACE encrypted_ts;

-- 列级加密
CREATE TABLE user_data (
  user_id NUMBER PRIMARY KEY,
  username VARCHAR2(50),
  password VARCHAR2(100) ENCRYPT USING 'AES256'
);
```

### 6.2 数据脱敏
```sql
-- 创建数据脱敏策略
BEGIN
  DBMS_REDACT.ADD_POLICY(
    object_schema => 'HR',
    object_name => 'EMPLOYEES',
    policy_name => 'EMPLOYEES_REDACT_POLICY',
    column_name => 'EMAIL',
    function_type => DBMS_REDACT.PARTIAL,
    function_parameters => 'VVVVF,1,*,5',
    expression => '1=1'  -- 始终脱敏
  );
END;
/

-- 查看脱敏后的数据
SELECT employee_id, first_name, last_name, email
FROM hr.employees WHERE department_id = 50;

-- 禁用脱敏策略
BEGIN
  DBMS_REDACT.DISABLE_POLICY(
    object_schema => 'HR',
    object_name => 'EMPLOYEES',
    policy_name => 'EMPLOYEES_REDACT_POLICY'
  );
END;
/
```

### 6.3 虚拟专用数据库 (VPD)
```sql
-- 创建行级安全策略函数
CREATE OR REPLACE FUNCTION employees_row_level_security(
  p_schema IN VARCHAR2,
  p_object IN VARCHAR2
) RETURN VARCHAR2 AS
  v_predicate VARCHAR2(200);
BEGIN
  -- 只有部门经理可以查看自己部门的所有员工
  -- 普通员工只能查看自己的信息
  IF SYS_CONTEXT('USERENV', 'SESSION_USER') = 'HR_MANAGER' THEN
    v_predicate := NULL;  -- 经理可以查看所有
  ELSE
    v_predicate := 'employee_id = SYS_CONTEXT(''USERENV'', ''SESSION_USERID'')';
  END IF;
  
  RETURN v_predicate;
END;
/

-- 创建VPD策略
BEGIN
  DBMS_RLS.ADD_POLICY(
    object_schema => 'HR',
    object_name => 'EMPLOYEES',
    policy_name => 'EMPLOYEES_VPD_POLICY',
    function_schema => 'HR',
    policy_function => 'employees_row_level_security',
    statement_types => 'SELECT, INSERT, UPDATE, DELETE'
  );
END;
/
```

## 7. 性能优化

### 7.1 SQL优化
```sql
-- 使用绑定变量
DECLARE
  v_employee_id NUMBER := 100;
BEGIN
  EXECUTE IMMEDIATE 'SELECT first_name, last_name FROM employees WHERE employee_id = :id'
  INTO v_first_name, v_last_name USING v_employee_id;
END;
/

-- 避免SELECT *
SELECT employee_id, first_name, last_name, salary FROM employees;

-- 合理使用索引
-- 创建适合查询的索引
CREATE INDEX idx_employees_dept_salary ON employees(department_id, salary);

-- 避免在索引列上使用函数
-- 不推荐
SELECT * FROM employees WHERE UPPER(last_name) = 'SMITH';
-- 推荐（使用函数索引）
CREATE INDEX idx_employees_upper_last_name ON employees(UPPER(last_name));
SELECT * FROM employees WHERE UPPER(last_name) = 'SMITH';
```

### 7.2 内存优化
```sql
-- 查看SGA使用情况
SELECT * FROM v$sga;
SELECT * FROM v$sga_dynamic_components;

-- 调整SGA大小
ALTER SYSTEM SET sga_target = 4G SCOPE=SPFILE;
ALTER SYSTEM SET sga_max_size = 4G SCOPE=SPFILE;

-- 查看PGA使用情况
SELECT * FROM v$pgastat;

-- 调整PGA大小
ALTER SYSTEM SET pga_aggregate_target = 2G SCOPE=SPFILE;
```

### 7.3 I/O优化
```sql
-- 表空间本地管理
CREATE TABLESPACE users_ts
DATAFILE 'users01.dbf' SIZE 100M
EXTENT MANAGEMENT LOCAL
SEGMENT SPACE MANAGEMENT AUTO;

-- 使用自动段空间管理
ALTER TABLE employees SEGMENT SPACE MANAGEMENT AUTO;

-- 合理设置块大小
-- 在创建数据库时设置默认块大小
-- 使用不同块大小的表空间
CREATE TABLESPACE large_blocks_ts
BLOCKSIZE 16K
DATAFILE 'large_blocks01.dbf' SIZE 100M;
```

## 8. 数据仓库特性

### 8.1 物化视图
```sql
-- 创建物化视图
CREATE MATERIALIZED VIEW mv_employee_department_summary
BUILD IMMEDIATE
REFRESH COMPLETE ON DEMAND
ENABLE QUERY REWRITE
AS
SELECT d.department_id, d.department_name, COUNT(*) AS employee_count, AVG(e.salary) AS avg_salary
FROM employees e JOIN departments d ON e.department_id = d.department_id
GROUP BY d.department_id, d.department_name;

-- 刷新物化视图
EXEC DBMS_MVIEW.REFRESH('mv_employee_department_summary');

-- 查询物化视图
SELECT * FROM mv_employee_department_summary;
```

### 8.2 分区交换
```sql
-- 创建临时表
CREATE TABLE new_orders (
  order_id NUMBER PRIMARY KEY,
  order_date DATE,
  customer_id NUMBER,
  total_amount NUMBER(8,2)
)
NOLOGGING;

-- 加载数据到临时表
INSERT /*+ APPEND */ INTO new_orders SELECT * FROM staging_orders;
COMMIT;

-- 交换分区
ALTER TABLE orders EXCHANGE PARTITION orders_q1_2024 WITH TABLE new_orders WITHOUT VALIDATION;
```

### 8.3 并行执行
```sql
-- 启用并行查询
ALTER SESSION ENABLE PARALLEL DML;
ALTER SESSION FORCE PARALLEL QUERY PARALLEL 4;

-- 并行插入
INSERT /*+ PARALLEL(4) APPEND */ INTO large_table SELECT * FROM source_table;

-- 并行查询
SELECT /*+ PARALLEL(4) */ COUNT(*) FROM large_table WHERE data LIKE '%pattern%';
```

## 9. 总结

Oracle数据库的高级特性为开发人员和数据库管理员提供了强大的功能，可以提高数据库性能、安全性和可管理性。本章节介绍了Oracle数据库的主要高级特性，包括：

- PL/SQL编程：变量、控制结构、游标等
- 存储过程和函数：封装业务逻辑
- 触发器：实现数据完整性和审计
- 索引优化：提高查询性能
- 分区表和分区索引：管理大表
- 高级安全特性：数据加密、脱敏、VPD
- 性能优化：SQL优化、内存优化、I/O优化
- 数据仓库特性：物化视图、分区交换、并行执行

通过深入学习和实践这些高级特性，您将能够充分利用Oracle数据库的强大功能，设计和实现高效、安全、可靠的数据库应用系统，成为一名真正的Oracle数据库专家。

下一章：[Oracle数据库最佳实践](06_最佳实践.md)