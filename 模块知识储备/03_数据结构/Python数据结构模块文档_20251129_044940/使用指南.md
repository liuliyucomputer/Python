# Python 数据结构模块使用指南

## 前言

本指南提供了对 Python 中五个核心数据结构模块（itertools、operator、collections、heapq、functools）的详细使用说明和实际应用示例。通过本指南，您将学习如何高效地使用这些模块来解决各种编程问题。

## 1. itertools 模块使用指南

### 1.1 无限迭代器的正确使用

**count 迭代器**

`count` 函数创建一个无限递增的迭代器，适用于需要无限序列的场景。

**正确用法：**
```python
import itertools

# 带条件的有限使用
for i in itertools.count(10, 2):  # 从10开始，步长2
    if i > 20:
        break
    print(i)  # 输出: 10, 12, 14, 16, 18, 20

# 与 zip 结合为数据添加索引
for index, value in zip(itertools.count(1), ['a', 'b', 'c']):
    print(f"{index}. {value}")
```

**常见错误：**
```python
# 错误：无限循环
# for i in itertools.count():  # 不要这样做！
#     print(i)
```

**cycle 迭代器**

`cycle` 函数无限循环遍历一个可迭代对象，适用于需要重复模式的场景。

**应用示例：** 轮询任务分配
```python
import itertools
import time

# 轮询三个服务器处理任务
servers = ['server1', 'server2', 'server3']
tasks = ['task1', 'task2', 'task3', 'task4', 'task5']

server_cycle = itertools.cycle(servers)

for task in tasks:
    server = next(server_cycle)
    print(f"分配任务 {task} 到 {server}")
    # 模拟处理时间
    time.sleep(0.1)
```

### 1.2 组合迭代器的高级应用

**排列与组合**

`permutations` 和 `combinations` 用于生成所有可能的排列和组合。

**应用示例：** 密码破解模拟（仅用于教育目的）
```python
import itertools

# 生成所有3位数字的组合
def generate_combinations(digits, length):
    return itertools.product(digits, repeat=length)

# 测试
for combo in generate_combinations('0123456789', 3):
    password = ''.join(combo)
    print(password)
    if password == '123':  # 假设目标密码是123
        print("找到密码!")
        break
```

**笛卡尔积**

`product` 生成多个集合的笛卡尔积，适用于多维度组合场景。

**应用示例：** 测试矩阵生成
```python
import itertools

# 生成测试参数矩阵
params = {
    'learning_rate': [0.01, 0.1, 0.5],
    'batch_size': [32, 64, 128],
    'optimizer': ['sgd', 'adam']
}

# 获取所有可能的参数组合
keys = params.keys()
values = params.values()

for combination in itertools.product(*values):
    config = dict(zip(keys, combination))
    print(config)
```

### 1.3 性能优化技巧

**内存使用优化**

比较不同实现方式的内存占用：

```python
import itertools
import sys

# 直接创建列表（内存密集）
data = list(range(1000000))
squared_list = [x*x for x in data]
print(f"列表推导式内存占用: {sys.getsizeof(squared_list) / 1024 / 1024:.2f} MB")

# 使用生成器表达式（内存高效）
squared_gen = (x*x for x in data)
print(f"生成器表达式内存占用: {sys.getsizeof(squared_gen)} 字节")

# 使用 itertools.starmap
pairs = [(x, 2) for x in data]
squared_map = itertools.starmap(pow, pairs)
print(f"starmap 内存占用: {sys.getsizeof(squared_map)} 字节")
```

## 2. operator 模块使用指南

### 2.1 排序键提取技巧

**itemgetter 的多级排序**

`itemgetter` 可以提取对象的特定属性或元素，非常适合作为排序键。

**应用示例：** 多级排序
```python
from operator import itemgetter

# 员工数据
employees = [
    {'name': 'Alice', 'department': 'HR', 'salary': 50000},
    {'name': 'Bob', 'department': 'Engineering', 'salary': 80000},
    {'name': 'Charlie', 'department': 'HR', 'salary': 55000},
    {'name': 'David', 'department': 'Engineering', 'salary': 75000},
    {'name': 'Eve', 'department': 'Marketing', 'salary': 60000}
]

# 先按部门升序，再按薪资降序排序
employees.sort(key=lambda x: (x['department'], -x['salary']))
# 等价于：
employees.sort(key=itemgetter('department', 'salary'), reverse=(False, True))

for emp in employees:
    print(f"{emp['department']}: {emp['name']} - ${emp['salary']}")
```

**attrgetter 用于对象属性**

当处理自定义对象时，`attrgetter` 非常有用。

```python
from operator import attrgetter

class Product:
    def __init__(self, name, price, category):
        self.name = name
        self.price = price
        self.category = category
    
    def __repr__(self):
        return f"Product({self.name}, ${self.price})"

products = [
    Product('Laptop', 999.99, 'Electronics'),
    Product('Phone', 499.99, 'Electronics'),
    Product('Desk', 199.99, 'Furniture'),
    Product('Chair', 89.99, 'Furniture')
]

# 按类别和价格排序
products.sort(key=attrgetter('category', 'price'))

for product in products:
    print(f"{product.category}: {product}")
```

### 2.2 函数式编程应用

**operator 与 functools.reduce 的结合**

```python
from operator import add, mul, sub
from functools import reduce

# 计算总和
numbers = [1, 2, 3, 4, 5]
sum_result = reduce(add, numbers)
print(f"总和: {sum_result}")  # 15

# 计算乘积
product_result = reduce(mul, numbers)
print(f"乘积: {product_result}")  # 120

# 使用初始值
sub_result = reduce(sub, numbers, 100)
print(f"100 - 1 - 2 - 3 - 4 - 5 = {sub_result}")  # 85
```

**动态操作选择**

```python
from operator import lt, gt, eq

# 动态选择比较操作符
def compare_values(a, b, op_type):
    operations = {
        '<': lt,
        '>': gt,
        '==': eq
    }
    
    if op_type in operations:
        return operations[op_type](a, b)
    else:
        raise ValueError(f"不支持的操作符: {op_type}")

# 测试
print(compare_values(5, 3, '>'))  # True
print(compare_values(5, 3, '<'))  # False
print(compare_values(5, 5, '=='))  # True
```

## 3. collections 模块使用指南

### 3.1 namedtuple 设计模式

**数据类的轻量级替代**

```python
from collections import namedtuple

# 定义一个 Point 命名元组
Point = namedtuple('Point', ['x', 'y', 'z'])

# 创建实例
p1 = Point(10, 20, 30)
p2 = Point(x=5, y=15, z=25)

# 访问字段
print(f"p1.x = {p1.x}, p1.y = {p1.y}, p1.z = {p1.z}")

# 转换为字典
print(p1._asdict())  # {'x': 10, 'y': 20, 'z': 30}

# 替换字段值
p3 = p1._replace(x=100)
print(p3)  # Point(x=100, y=20, z=30)
```

**应用示例：** 配置管理

```python
from collections import namedtuple

# 定义配置结构
Config = namedtuple('Config', [
    'host', 'port', 'username', 'timeout', 'retry_count'
])

# 创建默认配置
default_config = Config(
    host='localhost',
    port=8080,
    username='admin',
    timeout=30,
    retry_count=3
)

# 从环境变量或配置文件加载配置
def load_config_from_file(config_file):
    # 这里简化处理，实际应该读取文件
    return default_config._replace(host='api.example.com', port=443)

# 使用配置
config = load_config_from_file('config.json')
print(f"连接到 {config.host}:{config.port}，超时设置: {config.timeout}秒")
```

### 3.2 deque 双端队列优化

**高效队列操作**

```python
from collections import deque
import time

# 比较列表和 deque 的性能差异
def compare_performance():
    # 测试列表
    start = time.time()
    lst = []
    for i in range(100000):
        lst.insert(0, i)  # 在列表开头插入（O(n)操作）
    list_time = time.time() - start
    
    # 测试 deque
    start = time.time()
    dq = deque()
    for i in range(100000):
        dq.appendleft(i)  # 在 deque 开头插入（O(1)操作）
    deque_time = time.time() - start
    
    print(f"列表开头插入时间: {list_time:.6f}秒")
    print(f"deque开头插入时间: {deque_time:.6f}秒")
    print(f"性能提升: {list_time / deque_time:.2f}倍")

compare_performance()
```

**应用示例：** 滑动窗口

```python
from collections import deque

def sliding_window_max(nums, k):
    """计算滑动窗口的最大值"""
    result = []
    # 使用 deque 存储索引，保持单调递减
    q = deque()
    
    for i, num in enumerate(nums):
        # 移除超出窗口范围的元素
        while q and q[0] < i - k + 1:
            q.popleft()
        
        # 移除所有小于当前元素的值（保持单调性）
        while q and nums[q[-1]] < num:
            q.pop()
        
        # 添加当前元素索引
        q.append(i)
        
        # 当窗口形成时开始记录结果
        if i >= k - 1:
            result.append(nums[q[0]])
    
    return result

# 测试
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(sliding_window_max(nums, k))  # 输出: [3, 3, 5, 5, 6, 7]
```

### 3.3 Counter 高级统计技巧

**文本分析**

```python
from collections import Counter
import re

def analyze_text(text):
    # 提取单词（忽略大小写）
    words = re.findall(r'\b\w+\b', text.lower())
    
    # 计算词频
    word_counts = Counter(words)
    
    # 获取最常见的10个单词
    top_words = word_counts.most_common(10)
    
    return {
        'total_words': len(words),
        'unique_words': len(word_counts),
        'top_words': top_words,
        'word_counts': word_counts
    }

# 测试文本
text = """
Python is a high-level, interpreted, general-purpose programming language. 
Its design philosophy emphasizes code readability with the use of significant indentation. 
Python is dynamically-typed and garbage-collected. 
It supports multiple programming paradigms, including structured, object-oriented and functional programming.
"""

results = analyze_text(text)
print(f"总单词数: {results['total_words']}")
print(f"唯一单词数: {results['unique_words']}")
print("最常见的10个单词:")
for word, count in results['top_words']:
    print(f"  {word}: {count}")
```

## 4. heapq 模块使用指南

### 4.1 优先队列实现

**基本优先队列**

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0  # 用于在优先级相同时保持插入顺序
    
    def push(self, item, priority):
        # 使用负优先级来实现最大堆
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1
    
    def pop(self):
        if self._queue:
            return heapq.heappop(self._queue)[-1]
        raise IndexError("队列为空")
    
    def is_empty(self):
        return len(self._queue) == 0
    
    def size(self):
        return len(self._queue)

# 测试
pq = PriorityQueue()

# 添加任务
pq.push("编写报告", 3)
pq.push("回复邮件", 1)
pq.push("参加会议", 2)
pq.push("紧急修复", 5)
pq.push("整理文档", 2)

# 按优先级处理
while not pq.is_empty():
    task = pq.pop()
    print(f"处理任务: {task}")
```

**应用示例：** 任务调度系统

```python
import heapq
import time

class TaskScheduler:
    def __init__(self):
        self._tasks = []
        self._next_id = 0
    
    def schedule(self, task, delay_seconds=0):
        """安排任务在指定延迟后执行"""
        execution_time = time.time() + delay_seconds
        task_id = self._next_id
        self._next_id += 1
        heapq.heappush(self._tasks, (execution_time, task_id, task))
        return task_id
    
    def run_pending(self):
        """执行所有已到期的任务"""
        current_time = time.time()
        executed = 0
        
        while self._tasks and self._tasks[0][0] <= current_time:
            _, _, task = heapq.heappop(self._tasks)
            try:
                task()
                executed += 1
            except Exception as e:
                print(f"任务执行错误: {e}")
        
        return executed
    
    def pending_tasks(self):
        """返回待执行任务数量"""
        return len(self._tasks)

# 测试
scheduler = TaskScheduler()

# 定义任务
def task1():
    print(f"[{time.strftime('%H:%M:%S')}] 任务1执行")

def task2():
    print(f"[{time.strftime('%H:%M:%S')}] 任务2执行")

def task3():
    print(f"[{time.strftime('%H:%M:%S')}] 任务3执行")

# 安排任务
scheduler.schedule(task1, 1)  # 1秒后执行
scheduler.schedule(task2, 2)  # 2秒后执行
scheduler.schedule(task3, 0)  # 立即执行

print(f"待执行任务数: {scheduler.pending_tasks()}")

# 运行调度器
while scheduler.pending_tasks() > 0:
    executed = scheduler.run_pending()
    if executed == 0:
        # 没有任务可执行，等待一小段时间
        time.sleep(0.1)
    else:
        print(f"本次执行了 {executed} 个任务")
```

### 4.2 Top-K 问题解决方案

**查找最大/最小元素**

```python
import heapq
import random
import time

# 生成大量随机数据
data = [random.randint(1, 1000000) for _ in range(1000000)]

# 方法1：排序后切片
def method1(data, k):
    start = time.time()
    result = sorted(data, reverse=True)[:k]
    end = time.time()
    print(f"排序方法耗时: {(end - start)*1000:.2f} 毫秒")
    return result

# 方法2：使用 heapq.nlargest
def method2(data, k):
    start = time.time()
    result = heapq.nlargest(k, data)
    end = time.time()
    print(f"heapq.nlargest 耗时: {(end - start)*1000:.2f} 毫秒")
    return result

# 比较性能
k = 100
result1 = method1(data, k)
result2 = method2(data, k)

# 验证结果
print(f"结果一致: {sorted(result1) == sorted(result2)}")
```

## 5. functools 模块使用指南

### 5.1 缓存策略设计

**LRU 缓存的最佳实践**

```python
from functools import lru_cache
import time

# 示例：斐波那契数列计算

def fib_no_cache(n):
    """无缓存版本"""
    if n < 2:
        return n
    return fib_no_cache(n-1) + fib_no_cache(n-2)

@lru_cache(maxsize=128)
def fib_with_cache(n):
    """带 LRU 缓存版本"""
    if n < 2:
        return n
    return fib_with_cache(n-1) + fib_with_cache(n-2)

# 性能比较
def compare_performance():
    n = 35  # 计算第35个斐波那契数
    
    # 无缓存版本
    start = time.time()
    result1 = fib_no_cache(n)
    time1 = time.time() - start
    print(f"无缓存版本: 结果={result1}, 耗时={time1:.6f}秒")
    
    # 带缓存版本
    start = time.time()
    result2 = fib_with_cache(n)
    time2 = time.time() - start
    print(f"带缓存版本: 结果={result2}, 耗时={time2:.6f}秒")
    
    # 再次调用带缓存版本（应该非常快）
    start = time.time()
    result3 = fib_with_cache(n)
    time3 = time.time() - start
    print(f"缓存命中版本: 结果={result3}, 耗时={time3:.6f}秒")
    
    print(f"性能提升: {time1 / time2:.2f}倍")
    
    # 查看缓存统计信息
    print(f"缓存信息: {fib_with_cache.cache_info()}")

compare_performance()
```

**缓存键设计**

```python
from functools import lru_cache

class DataProcessor:
    @lru_cache(maxsize=1000)
    def process_data(self, data_hash, params):
        """
        使用数据哈希作为缓存键，避免传递大型数据对象
        
        Args:
            data_hash: 数据的哈希值或标识符
            params: 处理参数
        """
        # 这里应该是实际的数据处理逻辑
        print(f"处理数据: {data_hash}, 参数: {params}")
        return f"处理结果-{data_hash}-{params}"

# 使用示例
def example():
    processor = DataProcessor()
    
    # 第一次调用（缓存未命中）
    result1 = processor.process_data("data123", "default")
    
    # 第二次调用（缓存命中）
    result2 = processor.process_data("data123", "default")
    
    # 参数不同（缓存未命中）
    result3 = processor.process_data("data123", "special")
    
    print(f"缓存信息: {processor.process_data.cache_info()}")
    print(f"结果一致性: {result1 == result2}")

if __name__ == "__main__":
    example()
```

### 5.2 装饰器模式实现

**使用 wraps 保留原函数信息**

```python
from functools import wraps
import time

def timing_decorator(func):
    """记录函数执行时间的装饰器"""
    @wraps(func)  # 保留原函数的元数据
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"函数 {func.__name__} 执行时间: {(end_time - start_time)*1000:.2f} 毫秒")
        return result
    return wrapper

@timing_decorator
def slow_function(duration=0.5):
    """模拟耗时操作"""
    time.sleep(duration)
    return "完成"

# 测试
result = slow_function(0.3)
print(f"结果: {result}")
print(f"函数名: {slow_function.__name__}")  # 应该显示 'slow_function'
print(f"文档字符串: {slow_function.__doc__}")  # 应该显示原函数的文档
```

**应用示例：** 权限检查装饰器

```python
from functools import wraps

def require_permission(permission_level):
    """权限检查装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(user, *args, **kwargs):
            # 假设用户对象有 permission_level 属性
            if getattr(user, 'permission_level', 0) >= permission_level:
                return func(user, *args, **kwargs)
            else:
                raise PermissionError(f"权限不足，需要级别 {permission_level}，当前级别 {getattr(user, 'permission_level', 0)}")
        return wrapper
    return decorator

# 模拟用户类
class User:
    def __init__(self, name, permission_level=0):
        self.name = name
        self.permission_level = permission_level
    
    def __str__(self):
        return f"User({self.name}, 权限={self.permission_level})"

# 定义需要不同权限的函数
@require_permission(1)
def view_basic_info(user):
    return f"{user} 查看了基本信息"

@require_permission(3)
def modify_sensitive_data(user, data):
    return f"{user} 修改了敏感数据: {data}"

# 测试
admin = User("管理员", 5)
user = User("普通用户", 1)
guest = User("访客", 0)

try:
    print(view_basic_info(admin))  # 成功
    print(view_basic_info(user))   # 成功
    print(view_basic_info(guest))  # 失败
except PermissionError as e:
    print(f"错误: {e}")

try:
    print(modify_sensitive_data(admin, "密码修改"))  # 成功
    print(modify_sensitive_data(user, "密码修改"))   # 失败
except PermissionError as e:
    print(f"错误: {e}")
```

## 6. 模块组合实战案例

### 6.1 高效数据处理管道

```python
import itertools
from operator import itemgetter
from functools import lru_cache
from collections import defaultdict

def build_data_pipeline():
    # 模拟用户数据
    users = [
        {'id': 1, 'name': 'Alice', 'age': 30, 'department': 'HR', 'salary': 50000},
        {'id': 2, 'name': 'Bob', 'age': 25, 'department': 'Engineering', 'salary': 80000},
        {'id': 3, 'name': 'Charlie', 'age': 35, 'department': 'HR', 'salary': 55000},
        {'id': 4, 'name': 'David', 'age': 40, 'department': 'Engineering', 'salary': 90000},
        {'id': 5, 'name': 'Eve', 'age': 28, 'department': 'Marketing', 'salary': 60000},
        {'id': 6, 'name': 'Frank', 'age': 32, 'department': 'Engineering', 'salary': 75000},
        {'id': 7, 'name': 'Grace', 'age': 45, 'department': 'HR', 'salary': 65000}
    ]
    
    # 1. 过滤：获取30岁以上的员工
    filtered_users = itertools.filterfalse(lambda x: x['age'] < 30, users)
    
    # 2. 排序：按部门和薪资降序
    sorted_users = sorted(filtered_users, key=itemgetter('department', 'salary'), reverse=(False, True))
    
    # 3. 分组：按部门分组
    grouped = itertools.groupby(sorted_users, key=itemgetter('department'))
    
    # 4. 计算每个部门的平均薪资（带缓存）
    @lru_cache(maxsize=10)
    def calculate_average_salary(department_name, *salaries):
        return sum(salaries) / len(salaries) if salaries else 0
    
    # 5. 构建结果
    result = defaultdict(dict)
    
    for dept, employees in grouped:
        employee_list = list(employees)  # 转换为列表以重用
        salaries = tuple(emp['salary'] for emp in employee_list)
        
        result[dept]['employees'] = employee_list
        result[dept]['count'] = len(employee_list)
        result[dept]['average_salary'] = calculate_average_salary(dept, *salaries)
        result[dept]['total_salary'] = sum(salaries)
    
    return result

# 执行管道并显示结果
pipeline_result = build_data_pipeline()

for department, data in pipeline_result.items():
    print(f"部门: {department}")
    print(f"  员工数量: {data['count']}")
    print(f"  平均薪资: ${data['average_salary']:,.2f}")
    print(f"  总薪资: ${data['total_salary']:,.2f}")
    print("  员工列表:")
    for emp in data['employees']:
        print(f"    - {emp['name']} (年龄: {emp['age']}, 薪资: ${emp['salary']:,.2f})")
    print()
```

### 6.2 优先级任务调度系统

```python
import heapq
from functools import wraps
from collections import deque
import time
import threading
import random

class AdvancedTaskScheduler:
    def __init__(self):
        self._tasks = []  # 优先队列
        self._lock = threading.Lock()  # 线程锁
        self._next_id = 0  # 任务ID
        self._running = False
        self._thread = None
    
    def start(self):
        """启动调度器"""
        with self._lock:
            if self._running:
                print("调度器已经在运行")
                return
            self._running = True
        
        self._thread = threading.Thread(target=self._run_loop)
        self._thread.daemon = True
        self._thread.start()
        print("调度器已启动")
    
    def stop(self):
        """停止调度器"""
        with self._lock:
            self._running = False
        
        if self._thread:
            self._thread.join(timeout=1.0)
            print("调度器已停止")
    
    def schedule(self, task, priority=0, delay=0):
        """安排任务
        
        Args:
            task: 可调用对象
            priority: 优先级，数字越小优先级越高
            delay: 延迟执行的秒数
        
        Returns:
            任务ID
        """
        execution_time = time.time() + delay
        with self._lock:
            task_id = self._next_id
            self._next_id += 1
            heapq.heappush(self._tasks, (execution_time, priority, task_id, task))
        
        print(f"任务 {task_id} 已安排，优先级: {priority}，延迟: {delay}秒")
        return task_id
    
    def _run_loop(self):
        """调度器主循环"""
        while self._running:
            now = time.time()
            tasks_to_execute = []
            
            # 找出所有到期的任务
            with self._lock:
                while self._tasks and self._tasks[0][0] <= now:
                    tasks_to_execute.append(heapq.heappop(self._tasks)[-1])
            
            # 执行任务
            for task in tasks_to_execute:
                try:
                    task()
                except Exception as e:
                    print(f"任务执行错误: {e}")
            
            # 短暂休眠，避免CPU占用过高
            if not tasks_to_execute:
                time.sleep(0.1)
    
    def task_count(self):
        """返回待执行任务数量"""
        with self._lock:
            return len(self._tasks)

# 创建任务装饰器
def scheduled_task(scheduler, priority=0, delay=0):
    """将函数转换为调度任务"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 创建一个绑定了参数的任务函数
            def task_wrapper():
                return func(*args, **kwargs)
            
            # 调度任务
            task_id = scheduler.schedule(task_wrapper, priority, delay)
            return task_id
        return wrapper
    return decorator

# 测试
def main():
    scheduler = AdvancedTaskScheduler()
    scheduler.start()
    
    # 定义任务
    def regular_task():
        print(f"[{time.strftime('%H:%M:%S')}] 执行常规任务")
    
    def high_priority_task():
        print(f"[{time.strftime('%H:%M:%S')}] 执行高优先级任务!")
    
    def delayed_task():
        print(f"[{time.strftime('%H:%M:%S')}] 执行延迟任务")
    
    # 使用装饰器定义任务
    @scheduled_task(scheduler, priority=-10, delay=2)
    def critical_task(message):
        print(f"[{time.strftime('%H:%M:%S')}] 执行关键任务: {message}")
    
    # 调度任务
    scheduler.schedule(regular_task, priority=5)
    scheduler.schedule(regular_task, priority=5, delay=1)
    scheduler.schedule(high_priority_task, priority=-5, delay=0.5)
    scheduler.schedule(delayed_task, delay=3)
    
    # 使用装饰器调度任务
    task_id = critical_task("系统更新")
    print(f"关键任务ID: {task_id}")
    
    # 等待所有任务执行完成
    while scheduler.task_count() > 0:
        print(f"等待中，剩余任务数: {scheduler.task_count()}")
        time.sleep(1)
    
    # 停止调度器
    scheduler.stop()
    print("所有任务执行完成")

if __name__ == "__main__":
    main()
```

## 7. 最佳实践总结

### 7.1 选择合适的模块

| 使用场景 | 推荐模块 | 推荐函数/类 |
|---------|---------|------------|
| 内存优化的循环 | itertools | chain, islice, compress |
| 组合数学运算 | itertools | product, permutations, combinations |
| 自定义排序键 | operator | itemgetter, attrgetter |
| 高效队列操作 | collections | deque |
| 统计和计数 | collections | Counter |
| 命名数据结构 | collections | namedtuple |
| 优先队列实现 | heapq | heappush, heappop |
| 缓存计算结果 | functools | lru_cache |
| 函数装饰器 | functools | wraps |
| 部分应用函数 | functools | partial |

### 7.2 性能优化建议

1. **优先使用内置和标准库函数**：它们通常由 C 语言实现，性能更好
2. **选择合适的数据结构**：根据操作模式选择最适合的数据结构
3. **使用惰性求值**：尽可能使用迭代器而非创建完整列表
4. **合理使用缓存**：对计算密集型操作使用 `lru_cache`，但注意设置适当的缓存大小
5. **避免不必要的复制**：使用视图和引用而非复制数据

### 7.3 代码可读性提升

1. **使用有意义的名称**：为命名元组和自定义数据结构使用清晰的字段名
2. **添加适当的文档**：为复杂的算法和数据处理逻辑添加注释
3. **模块化设计**：将复杂功能分解为小的、可重用的函数
4. **使用装饰器**：使用装饰器封装横切关注点（如日志、性能监控）

## 8. 常见问题解答

**Q: itertools 生成的迭代器可以重用吗？**
A: 不可以。itertools 生成的迭代器是惰性求值的，一旦迭代完成，就不能再次使用。如果需要多次迭代相同的数据，请将结果保存到列表中，或者重新创建迭代器。

**Q: Counter 对象如何处理不存在的键？**
A: 与普通字典不同，Counter 在访问不存在的键时会返回 0，而不是抛出 KeyError 异常。这使得计数操作更加方便。

**Q: lru_cache 的缓存键有什么限制？**
A: lru_cache 的缓存键必须是可哈希的。这意味着不能使用列表、字典或其他可变对象作为参数，除非它们实现了 `__hash__` 方法。

**Q: heapq 实现的是最大堆还是最小堆？**
A: heapq 默认实现的是最小堆。如果需要最大堆，可以通过将值取相反数来实现，或者使用自定义的比较逻辑。

**Q: 如何判断应该使用 namedtuple 还是自定义类？**
A: 如果需要简单的数据存储，不需要方法或属性验证，namedtuple 是一个轻量级的选择。如果需要方法、属性验证或可变状态，则应该使用自定义类。

---

*本指南基于 Python 3.8+ 版本编写，部分功能可能需要较高版本的 Python 支持。*

*如有任何问题或建议，请联系技术支持团队。*
